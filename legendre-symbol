def isPrime(num):
	if num <= 3:
		return num > 1
	if num % 2 == 0 or num % 3 == 0:
		return False
	for factor in xrange(5, int(num ** 0.5) + 1, 6):
		if num % factor == 0 or num % (factor + 2) == 0:
			return False
	return True
	
def sieve(num):
    m = (num - 1)
    b = [True] * m
    i, p, primesList = 0, 3, [2]
    while p * p < num:
        if b[i]:
            primesList.append(p)
            j = 2 * i * i + 6 * i + 3
            while j < m:
                b[j] = False
                j = j + 2 * i + 3
        i += 1; p += 2
    while i < m:
        if b[i]:
            primesList.append(p)
        i += 1; p += 2
    return primesList
    
def primeFactorization(num):
	pFactor = []
	if isPrime(num):
		pFactor.append((num, 1))
	else:
		number = num
		primeList = sieve(num)
		for prime in primeList:
			factorCount = 0
			while number % prime == 0:
				number /= prime
				factorCount += 1
			if factorCount > 0:
				pFactor.append((prime, factorCount))
	return pFactor
	
def legendre(a, p):
	if a % p == 0 or (not isPrime(p)) or p == 2:
		return 0
	if a < -1:
		return legendre(-1, p) * legendre(a * -1, p)
	if a == -1:
		if p % 4 == 1:
			return 1
		else:
			return -1
	if a ** .5 == int(a ** .5):
		return 1
	if a == 2:
		if p % 8 == 1 or p % 8 == 7:
			return 1
		else:
			return -1
	if a > p:
		return legendre(a % p, p)
	elif isPrime(a) and isPrime(p):
		if a % 4 == 3 and p % 4 == 3:
			return -1 * legendre(p, a)
		else:
			return legendre(p, a)
	else:
		for prime in sieve(a):
			if a % prime == 0:
				return legendre(prime, p) * legendre(a / prime, p)
				break
