def lcm(a, b):
	return a * b / gcd(a, b)
 
def gcd(a, b):
	if (a % b == 0 or b % a == 0):
			return math.min(a, b)
	else:
		newNum = math.max(a, b) - (long)(math.max(a, b) / math.min(a, b)) * math.min(a, b)
		return gcd(newNum, math.min(a, b))
 
def linearCombo(a, b):
	if (a - b == gcd(a, b)):
		combo = {a, b}
    	return combo
	rem1 = Math.max(a, b)
	rem2 = Math.min(a, b)
	firstCoef1 = 1
	firstCoef2 = 0
	secondCoef1 = 0
	secondCoef2 = 1
	while (rem1 % rem2 != 0):
		divisor = (long)(rem1 / rem2)
		tempRem = rem1 - divisor * rem2
		tempFirstCoef = firstCoef1 - divisor * firstCoef2
		tempSecondCoef = secondCoef1 - divisor * secondCoef2
		rem1 = rem2
		rem2 = tempRem
		firstCoef1 = firstCoef2
		firstCoef2 = tempFirstCoef
		secondCoef1 = secondCoef2
		secondCoef2 = tempSecondCoef
	if (a > b):
		answer = {firstCoef2, secondCoef2};
		print (a + "(" + answer[0] + ")" + b + "(" + answer[1] + ") = " + gcd(a, b));
		return answer
	else:
		answer = {secondCoef2, firstCoef2}
		print (a + "(" + answer[0] + ") + " + b + "(" + answer[1] + ") = " + gcd(a, b));
		return answer
 
def modInverse(congruence):
		a = 1
		while ((congruence[0] * a) % congruence[2] != congruence[1]):
			a += 1
		arr = {1, a, congruence[2]};
		return arr
 
def incongruentSols(a, b, c):
	solutions = set()
	if (b % gcd(a, c) == 0):
		numSols = gcd(a, c);
		sol = (c + b * linearCombo(a, c)[0] / numSols) % c;
		for i in xrange(0, numSols - 1):
			solutions.add((sol + c * i / numSols) % c)
	return solutions

def solutionSystem(system)
	lcm = 1
	for i in xrange(0, system.length - 1)
		lcm = lcm(lcm, system[i][2])
		List<List<Integer>> pFactor = primeFactorization((int)lcm);
 
		int[][] newSystem = new int[pFactor.size()][3];
		for (int k = 0; k < pFactor.size(); k++)
		{
			int num = (int) Math.pow(pFactor.get(k).get(0), pFactor.get(k).get(1));
			for (int j = 0; j < system.length; j++)
			{
				if(system[j][2] % num == 0)
				{
					newSystem[k][0] = system[j][0];
					newSystem[k][1] = system[j][1] % num;
					newSystem[k][2] = num;
					break;
				}
			}
		}
		System.out.println(Arrays.deepToString(newSystem));
		int solution = 0;
		int ans = 1;
		for (int l = 0; l < newSystem.length; l++)
		{
			int a = newSystem[l][0];
			int b = 1;
			int c = newSystem[l][2];
 
			if (b % gcd(a, c) == 0)
			{
				int numSols = (int)gcd(a, c);
				ans = (int)(c + b * nlinearCombo(a, c)[0] / numSols) % c;
				for (int m = 0; m < newSystem.length; m++)
				{
					if (m != l)
					{
						ans *= newSystem[m][2];
					}
				}
			}
			ans = ans * (ans % c);
			solution += newSystem[l][1] * ans;
			System.out.println(ans);
		}
		return solution % (int)lcm;
	}
 
	public static void main (String[] args) throws java.lang.Exception
	{
		int[][] arr = {{1, 2, 4}, {1, 7, 9}};
		System.out.println(solutionSystem(arr));
	}
}
